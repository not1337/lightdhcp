diff -rNu dhcpcd-dhcpcd-8.1.6/configure.sh dhcpcd-8.1.6/configure.sh
--- dhcpcd-dhcpcd-8.1.6/configure.sh	1970-01-01 01:00:00.000000000 +0100
+++ dhcpcd-8.1.6/configure.sh	2020-04-11 14:51:30.196495174 +0200
@@ -0,0 +1,2 @@
+#!/bin/sh
+exec ./configure --dbdir=/var/lib/dhcpcd5 --rundir=/run --libexecdir=/lib/dhcpcd CFLAGS="-Os $* -DSCRIPT=NULL"
diff -rNu dhcpcd-dhcpcd-8.1.6/src/dhcp6.c dhcpcd-8.1.6/src/dhcp6.c
--- dhcpcd-dhcpcd-8.1.6/src/dhcp6.c	2020-01-27 21:22:21.000000000 +0100
+++ dhcpcd-8.1.6/src/dhcp6.c	2020-04-11 14:51:30.198495200 +0200
@@ -2466,6 +2466,7 @@
 static ssize_t
 dhcp6_writelease(const struct interface *ifp)
 {
+#if 0
 	const struct dhcp6_state *state;
 	int fd;
 	ssize_t bytes;
@@ -2481,11 +2482,16 @@
 	bytes = write(fd, state->new, state->new_len);
 	close(fd);
 	return bytes;
+#else
+	const struct dhcp6_state *state = D6_CSTATE(ifp);
+	return state->new_len;
+#endif
 }
 
 static int
 dhcp6_readlease(struct interface *ifp, int validate)
 {
+#if 0
 	struct dhcp6_state *state;
 	struct stat st;
 	int fd;
@@ -2585,11 +2591,16 @@
 
 ex:
 	dhcp6_freedrop_addrs(ifp, 0, NULL);
+#if 0
 	unlink(state->leasefile);
+#endif
 	free(state->new);
 	state->new = NULL;
 	state->new_len = 0;
 	return retval;
+#else
+	return 0;
+#endif
 }
 
 static void
@@ -3935,7 +3946,9 @@
 				dhcp6_startrelease(ifp);
 				return;
 			}
+#if 0
 			unlink(state->leasefile);
+#endif
 		}
 		dhcp6_freedrop_addrs(ifp, drop, NULL);
 		free(state->old);
diff -rNu dhcpcd-dhcpcd-8.1.6/src/dhcp.c dhcpcd-8.1.6/src/dhcp.c
--- dhcpcd-dhcpcd-8.1.6/src/dhcp.c	2020-01-27 21:22:21.000000000 +0100
+++ dhcpcd-8.1.6/src/dhcp.c	2020-04-11 14:51:30.199495213 +0200
@@ -1123,6 +1123,7 @@
 static ssize_t
 write_lease(const struct interface *ifp, const struct bootp *bootp, size_t len)
 {
+#if 0
 	int fd;
 	ssize_t bytes;
 	const struct dhcp_state *state = D_CSTATE(ifp);
@@ -1135,11 +1136,15 @@
 	bytes = write(fd, bootp, len);
 	close(fd);
 	return bytes;
+#else
+	return len;
+#endif
 }
 
 static size_t
 read_lease(struct interface *ifp, struct bootp **bootp)
 {
+#if 0
 	int fd;
 	bool fd_opened;
 	struct dhcp_state *state = D_STATE(ifp);
@@ -1227,6 +1232,9 @@
 out:
 	*bootp = (struct bootp *)lease;
 	return bytes;
+#else
+	return 0;
+#endif
 }
 
 static const struct dhcp_opt *
@@ -1890,7 +1898,9 @@
 
 	eloop_timeout_delete(ifp->ctx->eloop, NULL, ifp);
 	dhcp_drop(ifp, "EXPIRE");
+#if 0
 	unlink(state->leasefile);
+#endif
 	state->interval = 0;
 	if (!(ifp->options->options & DHCPCD_LINK) || ifp->carrier > LINK_DOWN)
 		dhcp_discover(ifp);
@@ -2033,7 +2043,9 @@
 
 	/* RFC 2131 3.1.5, Client-server interaction */
 	logerrx("%s: DAD detected %s", ifp->name, inet_ntoa(*ia));
+#if 0
 	unlink(state->leasefile);
+#endif
 	if (!(opts & DHCPCD_STATIC) && !state->lease.frominfo)
 		dhcp_decline(ifp);
 #ifdef IN_IFF_DUPLICATED
@@ -2688,7 +2700,9 @@
 			return;
 		state->state = DHS_RELEASE;
 
+#if 0
 		unlink(state->leasefile);
+#endif
 		if (ifp->carrier > LINK_DOWN &&
 		    state->new != NULL &&
 		    state->lease.server.s_addr != INADDR_ANY)
@@ -3047,7 +3061,9 @@
 			return;
 		if (!(ifp->ctx->options & DHCPCD_TEST)) {
 			dhcp_drop(ifp, "NAK");
+#if 0
 			unlink(state->leasefile);
+#endif
 		}
 
 		/* If we constantly get NAKS then we should slowly back off */
@@ -3692,8 +3708,10 @@
 	ifo = ifp->options;
 	/* We need to drop the leasefile so that dhcp_start
 	 * doesn't load it. */
+#if 0
 	if (ifo->options & DHCPCD_REQUEST)
 		unlink(state->leasefile);
+#endif
 
 	free(state->clientid);
 	state->clientid = NULL;
@@ -3860,6 +3878,7 @@
 			free(state->offer);
 			state->offer = NULL;
 			state->offer_len = 0;
+#if 0
 		} else if (!(ifo->options & DHCPCD_LASTLEASE_EXTEND) &&
 		    state->lease.leasetime != DHCP_INFINITE_LIFETIME &&
 		    stat(state->leasefile, &st) == 0)
@@ -3899,6 +3918,7 @@
 				state->lease.renewaltime -= l;
 				state->lease.rebindtime -= l;
 			}
+#endif
 		}
 	}
 
diff -rNu dhcpcd-dhcpcd-8.1.6/src/dhcpcd.c dhcpcd-8.1.6/src/dhcpcd.c
--- dhcpcd-dhcpcd-8.1.6/src/dhcpcd.c	2020-01-27 21:22:21.000000000 +0100
+++ dhcpcd-8.1.6/src/dhcpcd.c	2020-04-11 14:51:30.200495226 +0200
@@ -1989,6 +1989,7 @@
 		goto exit_failure;
 	}
 #endif
+	if(!ifo->script)usleep(500000);
 
 	logdebugx(PACKAGE "-" VERSION " starting");
 	ctx.options |= DHCPCD_STARTED;
diff -rNu dhcpcd-dhcpcd-8.1.6/src/dhcp-common.c dhcpcd-8.1.6/src/dhcp-common.c
--- dhcpcd-dhcpcd-8.1.6/src/dhcp-common.c	2020-01-27 21:22:21.000000000 +0100
+++ dhcpcd-8.1.6/src/dhcp-common.c	2020-04-11 14:51:30.200495226 +0200
@@ -158,8 +158,8 @@
 	return NULL;
 }
 
-ssize_t
-dhcp_vendor(char *str, size_t len)
+static ssize_t
+dhcp_vendor_uncached(char *str, size_t len)
 {
 	struct utsname utn;
 	char *p;
@@ -183,6 +183,23 @@
 	return p - str;
 }
 
+ssize_t
+dhcp_vendor(char *str, size_t len)
+{
+	static int cachestate = 0;
+	static int lencache;
+	static uint8_t strcache[VENDORCLASSID_MAX_LEN + 1];
+
+	if (!cachestate) {
+		cachestate = 1;
+		lencache = dhcp_vendor_uncached(strcache, sizeof(strcache));
+	}
+	if (lencache < 0 || lencache >= len)
+		return -1;
+	memcpy(str, strcache, lencache);
+	return lencache;
+}
+
 int
 make_option_mask(const struct dhcp_opt *dopts, size_t dopts_len,
     const struct dhcp_opt *odopts, size_t odopts_len,
diff -rNu dhcpcd-dhcpcd-8.1.6/src/duid.c dhcpcd-8.1.6/src/duid.c
--- dhcpcd-dhcpcd-8.1.6/src/duid.c	2020-01-27 21:22:21.000000000 +0100
+++ dhcpcd-8.1.6/src/duid.c	2020-04-11 14:51:30.200495226 +0200
@@ -57,6 +57,7 @@
 #include "duid.h"
 #include "logerr.h"
 
+#if 0
 static size_t
 duid_machineuuid(char *uuid, size_t uuid_len)
 {
@@ -117,6 +118,7 @@
 	l += hwaddr_aton(d, uuid);
 	return l;
 }
+#endif
 
 static size_t
 duid_make(uint8_t *d, const struct interface *ifp, uint16_t type)
@@ -151,6 +153,7 @@
 static size_t
 duid_get(uint8_t **d, const struct interface *ifp)
 {
+#if 0
 	FILE *fp;
 	uint8_t *data;
 	size_t len;
@@ -217,6 +220,17 @@
 		return duid_make(data, ifp, DUID_LL);
 	}
 	return len;
+#else
+	uint8_t *data;
+
+	if ((data = malloc(DUID_LEN)) == NULL) {
+		logerr(__func__);
+		return 0;
+	}
+	memset(data,0,DUID_LEN);
+	*d = data;
+	return duid_make(data, ifp, DUID_LL);
+#endif
 }
 
 size_t duid_init(const struct interface *ifp)
diff -rNu dhcpcd-dhcpcd-8.1.6/src/if-linux.c dhcpcd-8.1.6/src/if-linux.c
--- dhcpcd-dhcpcd-8.1.6/src/if-linux.c	2020-01-27 21:22:21.000000000 +0100
+++ dhcpcd-8.1.6/src/if-linux.c	2020-04-11 14:51:48.592729054 +0200
@@ -364,13 +364,21 @@
 	 * pid that doesn't clash with a process id for after we fork. */
 	memset(&snl, 0, sizeof(snl));
 	snl.nl_groups = RTMGRP_LINK;
-
+#if 0
 #ifdef INET
 	snl.nl_groups |= RTMGRP_IPV4_ROUTE | RTMGRP_IPV4_IFADDR;
 #endif
 #ifdef INET6
 	snl.nl_groups |= RTMGRP_IPV6_ROUTE | RTMGRP_IPV6_IFADDR | RTMGRP_NEIGH;
 #endif
+#else
+#ifdef INET
+	snl.nl_groups |= RTMGRP_IPV4_IFADDR;
+#endif
+#ifdef INET6
+	snl.nl_groups |= RTMGRP_IPV6_IFADDR;
+#endif
+#endif
 
 	ctx->link_fd = if_linksocket(&snl, NETLINK_ROUTE);
 	if (ctx->link_fd == -1)
@@ -1505,6 +1513,12 @@
 		return -1;
 #undef SF
 
+#ifdef PACKET_IGNORE_OUTGOING
+	n=1;
+	if(setsockopt(s,SOL_PACKET,PACKET_IGNORE_OUTGOING,&s,sizeof(s)))
+		goto eexit;
+#endif
+
 	/* We cannot validate the correct interface,
 	 * so we MUST set this first. */
 	if (bind(s, &su.sa, sizeof(su.sll)) == -1)
@@ -1955,6 +1969,7 @@
 int
 ip6_forwarding(const char *ifname)
 {
+#if 0
 	char path[256];
 	int val;
 
@@ -1963,6 +1978,9 @@
 	snprintf(path, sizeof(path), "%s/%s/forwarding", p_conf, ifname);
 	val = check_proc_int(path);
 	return val == -1 ? 0 : val;
+#else
+	return 0;
+#endif
 }
 
 #endif /* INET6 */
